{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Fix NIFTY Index Data Fetching Failure",
        "description": "Correct the critical startup error in `data_fetcher.py` that prevents fetching NIFTY index data. The current implementation fails with an 'Exception: Check the Tradingsymbol or Exchange' error. This fix is foundational for all subsequent operations.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "details": "In `data_fetcher.py`, locate the `get_nifty_spot_price` function. The current call `dhan.get_quotes(exchange='NSE_IDX', symbol='NIFTY 50')` is incorrect. Modify this call to use the correct parameters for the NIFTY 50 index: `security_id='13'` and `exchange='NSE_IDX'`. The updated call should be `dhan.get_quotes(security_id='13', exchange='NSE_IDX')`. Ensure the function successfully returns the NIFTY spot price.",
        "testStrategy": "Run `paper_trader.py` and confirm that the application no longer exits on startup. Verify that a valid NIFTY spot price is fetched and printed to the console (e.g., 'Successfully fetched NIFTY spot price: ...'). The 'Exception: Check the Tradingsymbol or Exchange' error should no longer appear in the logs.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Centralize Settings in config.py",
        "description": "Update `config.py` to include all necessary parameters for Phase 2, such as instrument types, exchange codes, and trade logging settings, to ensure modularity and ease of configuration.",
        "details": "Review `data_fetcher.py`, `paper_trader.py`, and `order_manager.py` for any hardcoded values. Move values like Security ID (`13`), Exchange (`NSE_IDX`), option instrument type (`OPTIDX`), and the trade log CSV filename to `config.py`. Import these values where needed.",
        "testStrategy": "After refactoring, run the application. Confirm it still fetches the NIFTY index price correctly using the new configuration values. Manually change a value in `config.py` (e.g., the log file name) and verify the change is reflected on the next run.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement ATM Option Symbol Resolution in order_manager.py",
        "description": "Develop the logic within `order_manager.py` to dynamically identify the At-the-Money (ATM) strike price and construct the correct CE and PE option symbols for the nearest expiry.",
        "details": "Create a function in `order_manager.py` that accepts the NIFTY spot price. This function should round the spot price to the nearest 50 to determine the ATM strike. Using this strike and the nearest expiry date convention, it should generate and return the full trading symbols for both the Call (CE) and Put (PE) options (e.g., 'NIFTY24JUL24500CE').",
        "testStrategy": "Write a small test script or unit test that calls the new function with various NIFTY spot prices (e.g., 24510, 24530, 24495) and asserts that the correct ATM strike and corresponding option symbols are returned.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create `get_option_ohlc` Function in data_fetcher.py",
        "description": "Implement a new function, `get_option_ohlc`, in `data_fetcher.py` to fetch 5-minute OHLC candle data for a given option symbol using the Dhan SDK.",
        "details": "This function will take an option symbol (e.g., 'NIFTY24JUL24500CE') and an exchange (e.g., 'NFO') as arguments. It will call the appropriate historical data function from `Dhan_Tradehull.py` to retrieve the 5-minute OHLC data for that specific option contract. The function should return the data in a pandas DataFrame.",
        "testStrategy": "Use a known, valid option symbol. Call the `get_option_ohlc` function and verify that it returns a pandas DataFrame with columns like 'Open', 'High', 'Low', 'Close', and 'Volume'. Check that the data appears valid and is for a 5-minute interval.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integrate Symbol Resolution into paper_trader.py",
        "description": "Refactor the main loop in `paper_trader.py` to call the symbol resolution logic from `order_manager.py` at the beginning of the trading session or periodically.",
        "details": "In the main execution block of `paper_trader.py`, after fetching the NIFTY spot price, call the function created in Task 3 to get the current ATM CE and PE option symbols. Store these symbols in variables for use within the main trading loop.",
        "testStrategy": "Run `paper_trader.py` and add print statements to display the fetched NIFTY spot price and the corresponding CE/PE symbols returned by `order_manager.py`. Verify the symbols are correct for the given spot price.",
        "priority": "medium",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Refactor Main Loop to Use Option Data Pipeline",
        "description": "Modify the main trading loop in `paper_trader.py` to fetch OHLC data for both the CE and PE option symbols identified in the previous step.",
        "details": "Inside the loop, use the CE and PE symbols obtained in Task 5. Call the `get_option_ohlc` function (from Task 4) twice, once for the call option and once for the put option. This will provide two separate DataFrames containing the candle data needed for strategy evaluation.",
        "testStrategy": "Run the application and log the head of the returned CE and PE DataFrames. Confirm that two distinct datasets are being fetched within each loop iteration and that they correspond to the correct ATM option symbols.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Apply Strategy Logic to CE and PE Option Data",
        "description": "Apply the trading logic from `strategy_v25.py` to the individual CE and PE option OHLC data streams to generate separate trading signals for each.",
        "details": "Pass the CE option DataFrame to the strategy function to get a signal (e.g., 'BUY_CE', 'SELL_CE'). Separately, pass the PE option DataFrame to the same strategy function to get its signal (e.g., 'BUY_PE', 'SELL_PE'). The system must now be able to process signals for two different instruments concurrently.",
        "testStrategy": "Add logging to show the input data (last few candles of CE/PE) and the resulting signal from `strategy_v25.py` for both the call and put options. Manually verify if a simple condition (e.g., price cross) in the data correctly triggers a 'BUY' or 'SELL' signal.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Option-Based Trade Simulation",
        "description": "Upgrade the trade simulation logic in `paper_trader.py` to execute and manage simulated trades based on the signals generated for the CE and PE options.",
        "details": "Refactor the existing paper trading state machine. It must now manage positions for CE and PE independently. For example, if a 'BUY_CE' signal is received, it should simulate entering a long call position. If 'SELL_CE' is received, it should close it. The same logic applies to the PE side.",
        "testStrategy": "Run a full simulation. Check the console output to verify that when a 'BUY_CE' signal is generated, the system logs 'Entering CE position', and when a 'SELL_CE' signal appears, it logs 'Exiting CE position' with a calculated P&L. Do the same for PE.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Enhance CSV Trade Logging for Options",
        "description": "Expand the trade logging functionality to save all simulated option trades to a CSV file with comprehensive details, including the exact option symbol, P&L, and timestamps.",
        "details": "Modify the function that writes to the trade log CSV. Ensure each row includes: timestamp, option symbol (e.g., 'NIFTY24JUL24500CE'), action ('BUY' or 'SELL'), price, quantity, and the calculated profit or loss for that specific trade. The log should clearly distinguish between CE and PE trades.",
        "testStrategy": "After a simulation run, open the generated trade log CSV file. Verify that it contains entries for both CE and PE trades and that all specified columns are present and correctly populated. Check P&L calculations for a few trades manually.",
        "priority": "low",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Robust Error Handling for SDK Calls",
        "description": "Increase system resilience by wrapping all external calls to the `Dhan_Tradehull.py` SDK in `try...except` blocks to gracefully handle potential API errors or network failures.",
        "details": "Go through `data_fetcher.py` and any other file that calls the SDK. Wrap every SDK function call (e.g., for fetching spot price, fetching OHLC data) in a `try...except` block. Log any exceptions with a clear error message (e.g., 'Failed to fetch data for symbol XYZ') and ensure the application can continue running or exit gracefully instead of crashing.",
        "testStrategy": "Temporarily modify an SDK call to use an invalid symbol to force an error. Confirm that the `except` block catches the error, a message is logged, and the application does not crash. Restore the correct symbol afterward.",
        "priority": "medium",
        "dependencies": [
          4,
          6
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-19T06:59:54.773Z",
      "updated": "2025-09-19T08:55:21.224Z",
      "description": "Tasks for master context"
    }
  }
}