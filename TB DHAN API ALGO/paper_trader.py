#Trader Baddu:D
# PAPER TRADER for Strategy V25 (TradeHull, Fusion)
import os
import pandas as pd
import numpy as np
import pytz
from datetime import datetime, time as dtime

from data_fetcher import get_nifty_ohlc, get_option_ohlc, set_tsl, get_nifty_spot_price
from strategy_v25 import EMA, MACD, ATR, check_entry
from order_manager import get_atm_option_symbols
from config import LOT_SIZE, CLIENT_ID, ACCESS_TOKEN
from Dhan_Tradehull import Tradehull

# Import strategy_v25 for signal and trade execution
import strategy_v25

# ----------------------
# Global configuration
# ----------------------
DEBUG = os.getenv("DEBUG", "0") == "1"
IST = pytz.timezone("Asia/Kolkata")
SESSION_START = dtime(9, 30)
SESSION_END = dtime(15, 25)
PAPER_LOG_FILE = "trade_logs/PaperTrade.csv"

# ----------------------
# Bootstrap Tradehull with preflight (fixes Invalid Token DH-906 early)
# ----------------------
try:
    print(f"[DEBUG] Initializing Tradehull with CLIENT_ID: {CLIENT_ID}, ACCESS_TOKEN: {ACCESS_TOKEN[:5]}...hidden")
    tsl = Tradehull(ClientCode=CLIENT_ID, token_id=ACCESS_TOKEN)
    set_tsl(tsl)  # set_tsl includes get_fund_limits preflight; will raise if token invalid
    print("[DEBUG] Tradehull client initialized and authenticated.")
except Exception as e:
    print(f"[FATAL] Could not init TradeHull client (token/auth): {e}")
    raise

# ----------------------
# Paper trade logging
# ----------------------
trade_memory = []

def log_paper_trade(entry, exit_time, exit_price, reason, lot_size=LOT_SIZE):
    """Append a trade row to CSV and in-memory for summary."""
    pnl_points = (exit_price - entry["entry_price"]) if entry["side"] == "BUY_CE" else (entry["entry_price"] - exit_price)
    pnl_inr = pnl_points * lot_size
    row = {
        "EntryTime": entry["entry_time"],
        "Side": entry["side"],
        "EntryPrice": float(entry["entry_price"]),
        "ExitTime": exit_time,
        "ExitPrice": float(exit_price),
        "Reason": reason,
        "PnL_Points": round(pnl_points, 2),
        "PnL_INR": round(pnl_inr, 2),
    }
    os.makedirs(os.path.dirname(PAPER_LOG_FILE), exist_ok=True)
    header = not os.path.exists(PAPER_LOG_FILE)
    pd.DataFrame([row]).to_csv(PAPER_LOG_FILE, mode="a", header=header, index=False)
    trade_memory.append(row)
    print(f"[PAPER LOG] {row}")

def print_summary():
    if not trade_memory:
        print("[SUMMARY] No trades taken")
        return
    df = pd.DataFrame(trade_memory)
    total = len(df)
    wins = (df["PnL_INR"] > 0).sum()
    winrate = (wins / total) * 100 if total else 0.0
    pnl_total = df["PnL_INR"].sum()
    print("\n=== PAPER TRADING SUMMARY ===")
    print(f"Total Trades: {total}")
    print(f"Winrate: {winrate:.2f}%")
    print(f"Net PnL: {pnl_total:.2f}")
    print("================================")

# ----------------------
# Helper: add indicators safely
# ----------------------
def add_indicators(df: pd.DataFrame) -> pd.DataFrame:
    """Compute EMA21, MACD, ATR for the given dataframe."""
    df = df.copy()
    df['datetime'] = pd.to_datetime(df['datetime'])
    df['ema21'] = EMA(df['close'], 21)
    df['macd'], df['macd_signal'], df['macd_hist'] = MACD(df['close'])
    df['atr'] = ATR(df)
    df = df.dropna().reset_index(drop=True)
    return df

# ----------------------
# Main Execution Logic
# ----------------------
def main():
    print("[INFO] Starting UNIFIED PAPER TRADER for Strategy V25")

    # 1. Fetch NIFTY index data to be the single source of truth for signals
    nifty_df = get_nifty_ohlc(interval=5)
    if nifty_df is None or nifty_df.empty:
        print("[ERROR] Could not fetch NIFTY index data. Aborting.")
        return
    
    nifty_df = add_indicators(nifty_df)
    print(f"[INFO] Fetched and prepared {len(nifty_df)} bars of NIFTY index data.")

    # 2. Run strategy_v25 backtest on index data to get trade signals
    # This function contains the canonical entry, exit, and TSL logic.
    # It returns a list of completed trades based on the index movement.
    print("[INFO] Generating trade signals from strategy_v25 using NIFTY data...")
    trade_signals = strategy_v25.backtest(nifty_df)
    
    if not trade_signals:
        print("[INFO] No trade signals were generated by the strategy for the given data.")
        print_summary()
        return
        
    print(f"[INFO] Generated {len(trade_signals)} trade signals. Now executing on option contracts...")

    # 3. Execute signals on actual option contracts
    for signal in trade_signals:
        entry_time, side, _, exit_time, _, reason, _ = signal

        # Ensure times are timezone-aware for accurate lookups
        entry_time = pd.to_datetime(entry_time).tz_localize(IST)
        exit_time = pd.to_datetime(exit_time).tz_localize(IST)

        # Find the spot price at entry time to resolve ATM contract
        spot_at_entry_row = nifty_df[nifty_df['datetime'] == entry_time]
        if spot_at_entry_row.empty:
            print(f"[WARN] Could not find NIFTY data for entry time {entry_time}. Skipping trade.")
            continue
        spot_at_entry = spot_at_entry_row['close'].iloc[0]

        try:
            # A. Resolve ATM option symbol for the entry time
            atm_symbols = get_atm_option_symbols(base_symbol="NIFTY", spot=spot_at_entry, when_dt=entry_time)
            option_symbol = atm_symbols['CE_symbol'] if side == "BUY_CE" else atm_symbols['PE_symbol']
            
            # B. Fetch OHLC for the chosen option contract
            option_df = get_option_ohlc(option_symbol, interval=5)
            if option_df.empty:
                print(f"[WARN] Could not fetch OHLC for {option_symbol} at {entry_time}. Skipping trade.")
                continue

            # C. Find option entry price
            entry_candle = option_df[option_df['datetime'] == entry_time]
            if entry_candle.empty:
                print(f"[WARN] No {option_symbol} candle found at entry time {entry_time}. Skipping trade.")
                continue
            option_entry_price = entry_candle['close'].iloc[0]

            # D. Find option exit price
            exit_candle = option_df[option_df['datetime'] == exit_time]
            if exit_candle.empty:
                # If exact exit time not found, use the last available candle before EOD
                available_candles = option_df[option_df['datetime'] <= exit_time]
                if not available_candles.empty:
                    exit_candle = available_candles.iloc[-1]
                    print(f"[WARN] Exact exit time {exit_time} not found for {option_symbol}. Using last known candle at {exit_candle['datetime'].iloc[0]}.")
                else:
                    print(f"[WARN] No {option_symbol} candle found for exit time {exit_time}. Skipping trade.")
                    continue
            
            option_exit_price = exit_candle['close'].iloc[0]
            actual_exit_time = exit_candle['datetime'].iloc[0]

            # E. Log the paper trade with actual option prices
            trade_entry = {
                "side": side,
                "entry_time": entry_time,
                "entry_price": option_entry_price,
            }
            log_paper_trade(trade_entry, actual_exit_time, option_exit_price, reason, LOT_SIZE)

        except Exception as e:
            print(f"[ERROR] Failed to execute trade for signal at {entry_time}: {e}")

    # 4. Print summary of all executed paper trades
    print_summary()


if __name__ == "__main__":
    main()